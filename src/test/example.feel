mod demo;

let main(): Void = {}

let a: Float = 0.1 + 0.3;

let mut b: Int = 321 - 300;

let c: Int = 2 * 2;

let c2 = 2 * 2;

let mut d: Int = b + c * 2;

let myTrue: Bool = true;

let myFalse: Bool = false;

let chr: Char = 'c';

let str: String = "Hello, world!";

let g(): Int = 1 + 2 + 3 + b;

let g2() = 1 + 2 + 3 + b;

let add(a: Int, b: Int): Int = a + b;

let calc(x: Int): Int = add(x, x) + x + 1;

let (T: Any)id(id: T): T = id;

let (T: Any)id2(id: T) = id;

let newline: Int = 1 + 1 +
                    1 + 1 + 1;

let semicolon(): Void = {
    let a = 1;
    let b = 2;
}

let call_id(): Void = {
    let a = (Int)id(1);
    let b = (Float)id(1.0);
}

let blockExpr1: Int = {
    let a = 0;
    let b = 0;
    a + b
}

let blockExpr2(): Int = {
    let a = 0;
    let b = 0;
    a + b
};

let blockExpr3: Void = {}

let compareExpr: Void = {
    let a = 1;
    let b = 1;
    let c = a == b;
    let d = a > b;
    let e = a != b;
    let f = a < b;
}

let logicExpr: Void = {
    let a = true & true;
    let b = true | false;
}

let ifExpr1: Int = if true then 0 else if true then 0 else 0;

let ifExpr2: Int = if true then { 0 } else { 1 }

let ifExpr3: Void = if true then {} else {}

let ifExpr4: Void = {
    if true do {}
    if true then {
    } else if true do {
        1
    }
}

let assignment: Void = {
    let mut a = 0;
    a = 1;
    a = 2
}

let whileStat(): Void = {
    let mut i = 0;
    while i <= 10 do {
        i = i + 1;
    }
}

let localFunction(): Int = {
    let f() = 123;
    let a = f();
    a
}

type Integer(v: Int);

type Point(x: Int, y: Int) with {
    copy(): Point = Point(x, y);
    plus(other: Point): Point = Point(x + other.x, y + other.y);
}

let somePoint: Point = Point(1, 2);

let memberAccess(a: Point, b: Point): Point = Point(a.x+b.x, a.y+b.y).copy();

type Color = { Red(), Green(), Blue() }

let red: Color = Red();

type IntList = {
    defaultValue(): Int = 0;
    value(): Int;
}

type Nil(): IntList with {
    value(): Int = 0;
}

type Cons(head: Int, tail: IntList): IntList with {
    value(): Int = head;
}

let makeIntList(): IntList = {
    let li: IntList = Cons(1, Cons(2, Cons(3, Nil())));
    li.value();
    li
}

let sumIntList(li: IntList): Int =
    if li as v: Cons then {
        v.head + sumIntList(v.tail)
    } else {
        0
    }

let typePattern(): Void = {
    let li: IntList = Cons(1, Cons(2, Cons(3, Nil())));
    let i =
        if li as v: Cons then {
            v.head
        } else {
            0
        }
}

let typePattern2(): Void = {
    let li: IntList = Cons(1, Cons(2, Cons(3, Nil())));
    if li as v: Cons then {
        v.head
    } else {
        0
    };
}

let identifierPattern(): Int = {
    let a = 1;
    if a as a then 123 else 123
}

let identifierPattern2(): Void = {
    let a = 1;
    if a as a then {
        localFunction()
    } else if a as b then {
        localFunction()
    } else {
        localFunction()
    };
}

let wildcardPattern(): Int = {
    let a = 1;
    if a as _ then 123 else 123
}

let wildcardPattern2(): Void = {
    let a = 1;
    if a as _ then {
        localFunction()
    } else if a as _ then {
        localFunction()
    } else {
        localFunction()
    };
}

let literalPattern(): Int = {
    let a = 1;
    if a as 1 then 123 else 123
}

let literalPattern2(): Void = {
    let a = 1;
    if a as 1 then {
        localFunction()
    } else if a as 1 then {
        localFunction()
    } else {
        localFunction()
    };
}

let ifDoLogical(): Void = {
    if true and true and true do {
        localFunction()
    }
    if true or true or true do {
        localFunction()
    }
    if true and true and true or true do {
        localFunction()
    }
    let a = 1;
    if a as 1 and a as 1 do {
        localFunction()
    }
    if a as 1 and a as 1 and (true or true and true) do {
        localFunction()
    }
    if (true or false) and a as 1 do {}
}

let ifThenElseLogical(): Void = {
    if true and true and true then {
        localFunction()
    } else { localFunction() }
    if true or true or true then {
        localFunction()
    } else { localFunction() }
    if true and true and true or true then {
        localFunction()
    } else { localFunction() }
    let a = 1;
    if a as 1 and a as 1 then {
        localFunction()
    } else { localFunction() };
}

let whileDoLogical(): Void = {
    while true and true and true do {
        localFunction()
    }
    while true or true or true do {
        localFunction()
    }
    while true and true and true or true do {
        localFunction()
    }
    let a = 1;
    while a as 1 and a as 1 do {
        localFunction()
    }
}

let (T)genericsFunction(a: T): T = {
    let b: T = a;
    b;
    a
}

let callGenericsFunction(): Int = (Int)genericsFunction(1);

type (T1, T2)Pair(first: T1, second: T2);

let genericsRecord(): Void = {
    let a: (Int, Int)Pair = (Int, Int)Pair(1, 2);
    a.first + a.second;
}

type (T)Option;
type (T)Some(value: T): (T)Option;
type (T)None(): (T)Option;

let genericsEnum(): Int = {
    let x: (Int)Option = (Int)Some(123);
    let y: (Int)Option = (Int)Some(123);
    if x as v: (Int)Some then v.value else 0
}

type (T1, T2)GenericsInterface;
type (T)ImplementType(): (T, Int)GenericsInterface;
type (T, R)ImplementType2(): (R, T)GenericsInterface;

let genericsSubtyping(): Void = {
    let i: (Int, Int)GenericsInterface = (Int)ImplementType();
    let j: (Int, Float)GenericsInterface = (Float, Int)ImplementType2();
}

let (E)genericsSubtyping2(): Void = {
    let i: (E, E)GenericsInterface = (E, E)ImplementType2();
}

let array(): Void = {
    let mut a = (Int)emptyArray();
    a = (Int)newArray(5, 5);
    let b = a.get(2);
    a.set(2, b);
}

type I1;
type I2 = {
    f(): Void;
    f2(a: Int): Int;
}

type C1(): I2 with {
    f(): Void = {};
    f2(a: Int): Int = a;
}

let interfaceInstance(): I2 = {
    let i: I2 = C1();
    let f(x: I2) = 123;
    f(C1());
    C1()
}

let (T: I2)interfaceConstraint(v: T): Void = {
    v.f();
    let x = v.f2(1);
    let i: I2 = v;
}

let instanceConstraint(): Void = {
    (C1)interfaceConstraint(C1());
}

type (T)Eq = {
    eq(other: T): Bool;
}

type EqFoo(): (EqFoo)Eq with {
    eq(other: EqFoo): Bool = true;
}

type EqBar(): I1;

given EqBar: (EqBar)Eq with {
    eq(other: EqBar): Bool = true;
}

type (T1: (T1)Eq, T2: (T2)Eq)EqPair(first: T1, second: T2): ((T1, T2)EqPair)Eq with {
    eq(other: (T1, T2)EqPair): Bool = first.eq(other.first) & second.eq(other.second);
}

type (T1, T2)EqPair2(first: T1, second: T2);

given (T1: (T1)Eq, T2: (T2)Eq)EqPair2: ((T1, T2)EqPair2)Eq with {
    eq(other: (T1, T2)EqPair2): Bool = first.eq(other.first) & second.eq(other.second);
}

let (T: (T)Eq)complicatedGenericsType(a: T, b: T): Bool = a.eq(b);

let complicatedGenericsType2(): Void = {
    (EqFoo)complicatedGenericsType(EqFoo(), EqFoo());
    let a = (EqFoo, EqFoo)EqPair(EqFoo(), EqFoo());
    ((EqFoo, EqFoo)EqPair)complicatedGenericsType(a, a);
    let b: ((EqFoo, EqFoo)EqPair)Eq = a;
    let c: ((EqBar, EqBar)EqPair2)Eq = (EqBar, EqBar)EqPair2(EqBar(), EqBar());
}

let functionType(x: Int, f: (Int)-> Int): Int = f(x);
let lambdaExpression(): Int = functionType(1, (a: Int) => a);
let lambdaExpression2(): Int = functionType(1, (b: Int): Int => b);

